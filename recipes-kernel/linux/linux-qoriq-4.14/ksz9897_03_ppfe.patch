diff --git a/drivers/staging/fsl_ppfe/Kconfig b/drivers/staging/fsl_ppfe/Kconfig
index e40964354cad..47a17cb89cf5 100644
--- a/drivers/staging/fsl_ppfe/Kconfig
+++ b/drivers/staging/fsl_ppfe/Kconfig
@@ -17,4 +17,10 @@ config FSL_PPFE_UTIL_DISABLED
 	---help---
 	UTIL PE has to be enabled only if required.
 
+config PPFE_KSZ9897
+	bool "Enable support for KSZ9897 on PPFE"
+	depends on (I2C_KSZ9897 || SPI_KSZ9897)
+	---help---
+	  Supports the Microchip KSZ9897 switch used within then PPFE.
+
 endif # FSL_PPFE
diff --git a/drivers/staging/fsl_ppfe/ksz_9897.h b/drivers/staging/fsl_ppfe/ksz_9897.h
new file mode 100644
index 000000000000..dd669633b22e
--- /dev/null
+++ b/drivers/staging/fsl_ppfe/ksz_9897.h
@@ -0,0 +1,81 @@
+#ifndef _KSZ_9897_H_
+#define _KSZ_9897_H_
+
+#include <linux/kernel.h>
+#include <linux/of_net.h>
+#include <linux/i2c.h>
+
+#include "pfe_hif_lib.h"
+#include "pfe_eth.h"
+
+#define KSZ_PORT	1
+
+struct ksz_device_port {
+	bool	enabled;
+};
+
+struct ksz_device {
+	u32 bus_id;
+	u32 phy_id;
+	phy_interface_t interface;
+	struct ksz_device_port port[7];
+};
+
+static inline int ksz_platform_data(const struct device_node *of_node,
+				struct ls1012a_eth_platform_data *data)
+{
+	struct device_node *dn = NULL;
+	struct ksz_device *ksz;
+	const uint32_t *p;
+	int id;
+
+	dn = of_get_child_by_name(of_node, "ksz9897");
+
+	if (dn == NULL)
+		return 0;
+
+	ksz = kzalloc(sizeof(struct ksz_device), GFP_KERNEL);
+
+	if (ksz == NULL)
+		return -ENOMEM;
+
+	data->ksz = ksz;
+	p = of_get_property(dn, "reg", NULL);
+
+	if (p)
+		ksz->bus_id = be32_to_cpup(p);
+
+	ksz->phy_id = 0xff;
+
+	for_each_node_by_name(dn, "ethernet-phy") {
+
+		p = of_get_property(dn, "reg", NULL);
+
+		if (p)
+			id = be32_to_cpup(p);
+		else
+			continue;
+
+		if (id < 0 || id > 6)
+			continue;
+
+		ksz->port[id].enabled = 1;
+
+		if (ksz->phy_id == 0xff)
+			ksz->phy_id = id;
+
+		ksz->interface = of_get_phy_mode(dn);
+
+		if (ksz->interface < 0) {
+			if (id < 5)
+				ksz->interface = PHY_INTERFACE_MODE_GMII;
+			else
+				pr_err("%s:%d Incorrect Phy mode....\n",
+							__func__, __LINE__);
+		}
+	}
+
+	return 1;
+}
+
+#endif	/* _KSZ_9897_H_ */
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.c b/drivers/staging/fsl_ppfe/pfe_eth.c
index c1a3f09cddac..ad9b93cae75f 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.c
+++ b/drivers/staging/fsl_ppfe/pfe_eth.c
@@ -35,6 +35,7 @@
 #include <linux/timer.h>
 #include <linux/hrtimer.h>
 #include <linux/platform_device.h>
+#include <linux/of_mdio.h>
 
 #include <net/ip.h>
 #include <net/sock.h>
@@ -60,6 +61,10 @@
 
 bool pfe_errata_a010897;
 
+#ifdef CONFIG_PPFE_KSZ9897
+#include "ksz_9897.h"
+#endif
+
 static void *cbus_emac_base[3];
 static void *cbus_gpi_base[3];
 
@@ -981,7 +986,6 @@ static int pfe_eth_mdio_init(struct pfe_eth_priv_s *priv,
 	snprintf(bus->id, MII_BUS_ID_SIZE, "ls1012a-%x", priv->id);
 	bus->priv = priv;
 
-	bus->phy_mask = minfo->phy_mask;
 	priv->mdc_div = minfo->mdc_div;
 
 	if (!priv->mdc_div)
@@ -991,9 +995,7 @@ static int pfe_eth_mdio_init(struct pfe_eth_priv_s *priv,
 
 	bus->parent = priv->pfe->dev;
 
-	netif_info(priv, drv, priv->ndev, "%s: mdc_div: %d, phy_mask: %x\n",
-		   __func__, priv->mdc_div, bus->phy_mask);
-	rc = mdiobus_register(bus);
+	rc = of_mdiobus_register(bus, minfo->np);
 	if (rc) {
 		netdev_err(priv->ndev, "mdiobus_register(%s) failed\n",
 			   bus->name);
@@ -1266,6 +1268,12 @@ static int pfe_phy_init(struct net_device *ndev)
 	char phy_id[MII_BUS_ID_SIZE + 3];
 	char bus_id[MII_BUS_ID_SIZE];
 	phy_interface_t interface;
+	const char *busname = "ls1012a-%d";
+	u32 bid = 0;
+	u32 pid = priv->einfo->phy_id;
+#ifdef CONFIG_PPFE_KSZ9897
+	struct ksz_device *ksz = priv->einfo->ksz;
+#endif
 	struct device_node *phy_node;
 	int rc;
 
@@ -1273,9 +1281,16 @@ static int pfe_phy_init(struct net_device *ndev)
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
 
-	snprintf(bus_id, MII_BUS_ID_SIZE, "ls1012a-%d", 0);
-	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
-		 priv->einfo->phy_id);
+#ifdef CONFIG_PPFE_KSZ9897
+	if (ksz != NULL) {
+		busname = "sw.%d";
+		bid = ksz->bus_id;
+		pid = ksz->phy_id;
+	}
+#endif
+
+	snprintf(bus_id, MII_BUS_ID_SIZE, busname, bid);
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id, pid);
 
 	netif_info(priv, drv, ndev, "%s: %s\n", __func__, phy_id);
 	interface = priv->einfo->mii_config;
@@ -1297,6 +1312,12 @@ static int pfe_phy_init(struct net_device *ndev)
 	priv->oldlink = 0;
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
+
+#ifdef CONFIG_PPFE_KSZ9897
+	if (ksz != NULL && ksz->interface > 0)
+		interface = ksz->interface;
+#endif
+
 	pr_info("%s interface %x\n", __func__, interface);
 
 	if (of_phy_is_fixed_link(priv->phy_node)) {
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.h b/drivers/staging/fsl_ppfe/pfe_eth.h
index 64b33485be98..4807c583cf58 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.h
+++ b/drivers/staging/fsl_ppfe/pfe_eth.h
@@ -61,13 +61,16 @@ struct ls1012a_eth_platform_data {
 	u32 phy_id;
 	u32 mdio_muxval;
 	u8 mac_addr[ETH_ALEN];
+#ifdef CONFIG_PPFE_KSZ9897
+	struct ksz_device *ksz;
+#endif
 	struct device_node	*phy_node;
 };
 
 struct ls1012a_mdio_platform_data {
 	int enabled;
 	int irq[32];
-	u32 phy_mask;
+	struct device_node *np;
 	int mdc_div;
 };
 
diff --git a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
index 56cb02e61221..548289d17fd9 100644
--- a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
+++ b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
@@ -30,6 +30,10 @@
 
 #include "pfe_mod.h"
 
+#ifdef CONFIG_PPFE_KSZ9897
+#include "ksz_9897.h"
+#endif
+
 struct ls1012a_pfe_platform_data pfe_platform_data;
 
 static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
@@ -37,7 +41,7 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 					struct ls1012a_pfe_platform_data
 					*pdata)
 {
-	struct device_node *gem = NULL, *phy = NULL;
+	struct device_node *gem = NULL;
 	int size;
 	int ii = 0, phy_id = 0;
 	const u32 *addr;
@@ -87,7 +91,6 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	} else {
 		phy_id = be32_to_cpup(addr);
 		pdata->ls1012a_eth_pdata[port].phy_id = phy_id;
-		pdata->ls1012a_mdio_pdata[port].phy_mask = ~(1 << phy_id);
 	}
 
 	addr = of_get_property(gem, "fsl,mdio-mux-val", &size);
@@ -113,9 +116,9 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	if (pdata->ls1012a_eth_pdata[port].phy_flags & GEMAC_NO_PHY)
 		goto done;
 
-	phy = of_get_next_child(gem, NULL);
+	pdata->ls1012a_mdio_pdata[port].np = of_get_child_by_name(gem, "mdio");
 
-	addr = of_get_property(phy, "reg", &size);
+	addr = of_get_property(pdata->ls1012a_mdio_pdata[port].np, "reg", &size);
 
 	if (!addr)
 		pr_err("%s:%d Invalid phy enable flag....\n",
@@ -125,6 +128,12 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 
 	pdata->ls1012a_mdio_pdata[port].irq[0] = PHY_POLL;
 
+#ifdef CONFIG_PPFE_KSZ9897
+	if (port == 1)
+		ksz_platform_data(gem, &pdata->ls1012a_eth_pdata[port]);
+
+#endif
+
 done:
 	if (of_phy_is_fixed_link(gem))
 		pdata->ls1012a_eth_pdata[port].phy_node = of_node_get(gem);
