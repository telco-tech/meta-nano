diff --git a/drivers/staging/fsl_ppfe/Kconfig b/drivers/staging/fsl_ppfe/Kconfig
index e409643..47a17cb 100644
--- a/drivers/staging/fsl_ppfe/Kconfig
+++ b/drivers/staging/fsl_ppfe/Kconfig
@@ -17,4 +17,10 @@ config FSL_PPFE_UTIL_DISABLED
 	---help---
 	UTIL PE has to be enabled only if required.
 
+config PPFE_KSZ9897
+	bool "Enable support for KSZ9897 on PPFE"
+	depends on (I2C_KSZ9897 || SPI_KSZ9897)
+	---help---
+	  Supports the Microchip KSZ9897 switch used within then PPFE.
+
 endif # FSL_PPFE
diff --git a/drivers/staging/fsl_ppfe/ksz_9897.h b/drivers/staging/fsl_ppfe/ksz_9897.h
new file mode 100644
index 0000000..8ab0c75
--- /dev/null
+++ b/drivers/staging/fsl_ppfe/ksz_9897.h
@@ -0,0 +1,78 @@
+#ifndef _KSZ_9897_H_
+#define _KSZ_9897_H_
+
+#include <linux/kernel.h>
+#include <linux/of_net.h>
+
+#include "pfe_hif_lib.h"
+#include "pfe_eth.h"
+
+struct ksz_device_port {
+	bool	enabled;
+};
+
+struct ksz_device {
+	u32 bus_id;
+	u32 phy_id;
+	phy_interface_t interface;
+	struct ksz_device_port port[7];
+};
+
+static inline int ksz_platform_data(const struct device_node *of_node,
+				struct ls1012a_eth_platform_data *data)
+{
+	struct device_node *dn = NULL;
+	struct ksz_device *ksz;
+	const uint32_t *p;
+	int id;
+
+	dn = of_get_child_by_name(of_node, "ksz9897");
+
+	if (dn == NULL)
+		return 0;
+
+	ksz = kzalloc(sizeof(struct ksz_device), GFP_KERNEL);
+
+	if (ksz == NULL)
+		return -ENOMEM;
+
+	data->ksz = ksz;
+	p = of_get_property(dn, "reg", NULL);
+
+	if (p)
+		ksz->bus_id = be32_to_cpup(p);
+
+	ksz->phy_id = 0xff;
+
+	for_each_node_by_name(dn, "ethernet-phy") {
+
+		p = of_get_property(dn, "reg", NULL);
+
+		if (p)
+			id = be32_to_cpup(p);
+		else
+			continue;
+
+		if (id < 0 || id > 6)
+			continue;
+
+		ksz->port[id].enabled = 1;
+
+		if (ksz->phy_id == 0xff)
+			ksz->phy_id = id;
+
+		ksz->interface = of_get_phy_mode(dn);
+
+		if (ksz->interface < 0) {
+			if (id < 5)
+				ksz->interface = PHY_INTERFACE_MODE_GMII;
+			else
+				pr_err("%s:%d Incorrect Phy mode....\n",
+							__func__, __LINE__);
+		}
+	}
+
+	return 0;
+}
+
+#endif	/* _KSZ_9897_H_ */
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.c b/drivers/staging/fsl_ppfe/pfe_eth.c
index 7ca1a48..a24f686 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.c
+++ b/drivers/staging/fsl_ppfe/pfe_eth.c
@@ -52,6 +52,10 @@
 #include "pfe_mod.h"
 #include "pfe_eth.h"
 
+#ifdef CONFIG_PPFE_KSZ9897
+#include "ksz_9897.h"
+#endif
+
 static void *cbus_emac_base[3];
 static void *cbus_gpi_base[3];
 
@@ -1183,14 +1187,27 @@ static int pfe_phy_init(struct net_device *ndev)
 	char phy_id[MII_BUS_ID_SIZE + 3];
 	char bus_id[MII_BUS_ID_SIZE];
 	phy_interface_t interface;
+	const char *busname = "ls1012a-%d";
+	u32 bid = priv->einfo->bus_id;
+	u32 pid = priv->einfo->phy_id;
+#ifdef CONFIG_PPFE_KSZ9897
+	struct ksz_device *ksz = priv->einfo->ksz;
+#endif
 
 	priv->oldlink = 0;
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
 
-	snprintf(bus_id, MII_BUS_ID_SIZE, "ls1012a-%d", priv->einfo->bus_id);
-	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id,
-		 priv->einfo->phy_id);
+#ifdef CONFIG_PPFE_KSZ9897
+	if (ksz != NULL) {
+		busname = "sw.%d";
+		bid = ksz->bus_id;
+		pid = ksz->phy_id;
+	}
+#endif
+
+	snprintf(bus_id, MII_BUS_ID_SIZE, busname, bid);
+	snprintf(phy_id, MII_BUS_ID_SIZE + 3, PHY_ID_FMT, bus_id, pid);
 
 	netif_info(priv, drv, ndev, "%s: %s\n", __func__, phy_id);
 	interface = priv->einfo->mii_config;
@@ -1212,6 +1229,12 @@ static int pfe_phy_init(struct net_device *ndev)
 	priv->oldlink = 0;
 	priv->oldspeed = 0;
 	priv->oldduplex = -1;
+
+#ifdef CONFIG_PPFE_KSZ9897
+	if (ksz != NULL && ksz->interface > 0)
+		interface = ksz->interface;
+#endif
+
 	pr_info("%s interface %x\n", __func__, interface);
 	phydev = phy_connect(ndev, phy_id, &pfe_eth_adjust_link, interface);
 
diff --git a/drivers/staging/fsl_ppfe/pfe_eth.h b/drivers/staging/fsl_ppfe/pfe_eth.h
index 721bef3..9beaddc 100644
--- a/drivers/staging/fsl_ppfe/pfe_eth.h
+++ b/drivers/staging/fsl_ppfe/pfe_eth.h
@@ -61,6 +61,9 @@ struct ls1012a_eth_platform_data {
 	u32 phy_id;
 	u32 mdio_muxval;
 	u8 mac_addr[ETH_ALEN];
+#ifdef CONFIG_PPFE_KSZ9897
+	struct ksz_device *ksz;
+#endif
 };
 
 struct ls1012a_mdio_platform_data {
diff --git a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
index 99adbaba..a37edf1 100644
--- a/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
+++ b/drivers/staging/fsl_ppfe/pfe_ls1012a_platform.c
@@ -28,6 +28,10 @@
 
 #include "pfe_mod.h"
 
+#ifdef CONFIG_PPFE_KSZ9897
+#include "ksz_9897.h"
+#endif
+
 struct ls1012a_pfe_platform_data pfe_platform_data;
 
 static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
@@ -110,7 +114,7 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 	if (pdata->ls1012a_eth_pdata[port].phy_flags & GEMAC_NO_PHY)
 		goto done;
 
-	phy = of_get_next_child(gem, NULL);
+	phy = of_get_child_by_name(gem, "mdio");
 
 	addr = of_get_property(phy, "reg", &size);
 
@@ -122,6 +126,10 @@ static int pfe_get_gemac_if_proprties(struct device_node *parent, int port, int
 
 	pdata->ls1012a_mdio_pdata[port].irq[0] = PHY_POLL;
 
+#ifdef CONFIG_PPFE_KSZ9897
+	ksz_platform_data(gem, &pdata->ls1012a_eth_pdata[port]);
+#endif
+
 done:
 
 	return 0;
